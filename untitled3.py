# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1obq8arYpGFp8Me3AM2t1eDJSbEVYc5I9

1.
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x_i):
    # your code here!
    fx = 4*x_i**3
    
    return fx

l = 0# lower bound for x
b = 1# upper bound for x
x = np.linspace(l, b) # we plot f(x) and g(x) for these values    

f_all_x = [f(x_i) for x_i in x]

plt.plot(x, f_all_x, lw=2, color='black', label='$f(x)$')

"""2.  f(x) = 4x^3
 

    F(x) = (1/4) 4x^4 = x^4                0<=x<=1
    F(x) = 1^4-0^4=1
    Finv(x) --> y^4 = x --> y = x^1/4
    Finv(x) = 1^1/4-0^1/4 = 1

3. a.
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x_i):
    # your code here!
    fx = 4*x_i**3
    
    return fx

def F_inv(u_i):
    # your code here
    F_inv_u = u_i**(1/4)
    return F_inv_u
    
    
m = 10 # some high number so we see smooth plots of f(x) 



l = 0# lower bound for x
b = 1# upper bound for x
x = np.linspace(l, b, num=m) # we plot f(x) and g(x) for these values

# Want to compute f(x_i) for all these points, for example for plotting? Use:
f_all_x = [f(x_i) for x_i in x]

#plt.hist(x_i)
density=True
histtype='stepfilled'
plt.plot(x, f_all_x, lw=2, color='black', label='$f(x)$')
# add additional plotting aspects, such as axis labels!

n = 1000# number of samples

samples =list()


for i in range(n):
    u_i = np.random.uniform(0,1)
    x_i=F_inv(u_i)
    samples.append(x_i)
    

plt.hist(samples,bins=50, density=True,histtype='stepfilled')
plt.show

# plot the samples using plt.hist()
# The argument 'bins=' determines in how many small subsets you visualize the
# samples. If you use very few, your approximation looks crude. I would use at
# least 50. 

#### Plotting tips
# To plot your large collection of samples, use a histogram, via plt.hist()
# It needs the arguments 'density=True', and 'histtype='stepfilled' or it will 
# not visualize correctly!

# If you want to plot a point (x_i, 0), you can use the argument 
# 'clip_on=False'. This way, the point will be plotted on top of the axis 
# boundary, instead of being hidden behind it.

"""4.

1.
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x_i):
    # your code here!
    fx = (2/3)*(np.cos(4*np.pi*x_i))**2
    
    return fx

l = 0# lower bound for x
b = 1# upper bound for x
x = np.linspace(l, b) # we plot f(x) and g(x) for these values    

f_all_x = [f(x_i) for x_i in x]

plt.plot(x, f_all_x, lw=2, color='black', label='$f(x)$')

"""2."""

import numpy as np
import matplotlib.pyplot as plt

def f(x_i):
    # your code here!
    fx = (2/3)*(np.cos(4*np.pi*x_i))**2
    
    return fx

def g(x_i):
    # your code here!
    gx = np.random.uniform(1,0)
    
    return gx

l = 0# lower bound for x
b = 1# upper bound for x
x = np.linspace(l, b) # we plot f(x) and g(x) for these values    

f_all_x = [f(x_i) for x_i in x]
g_all_x = [g(x_i) for x_i in x]

plt.plot(x, f_all_x, lw=2, color='black', label='$f(x)$')
plt.plot(x, g_all_x, lw=2, color='red', label = 'g(x)')

"""3. 
M = 3

4.
"""

import numpy as np
import matplotlib.pyplot as plt

def f(x_i):
    # your code here!
    fx = (2/3)*(np.cos(4*np.pi*x_i))**2
    
    return fx

def g(x_i):
    # your code here!
    gx = 1
    
    return gx
    
    
m = 200 # some high number so we see smooth plots of f(x) and g(x)
M = 3 # our scaling factor for M * g(x)


l = 0 #lower bound for x
b = 1 #upper bound for x
x = np.linspace(l, b, num=m) # we plot f(x) and g(x) for these values

# Want to compute f(x_i) for all these points, for example for plotting? Use:
f_all_x = [f(x_i) for x_i in x]
g_all_x = [M*g(x_i) for x_i in x]

plt.figure()
plt.plot(x, f_all_x, lw=2, color='black', label = 'f(x)')
plt.plot(x, g_all_x, lw=2, color='red', label = 'g(x)')
plt.xlabel('x')
plt.ylabel('y')


n = 10 # number of samples

samples = list()

for i in range(n):
  
    x_i = np.random.uniform(1,0) # potential point - if we accept it
    # do the rejection algorithm
    if np.random.uniform(0,M*g(x_i)) < f(x_i):# add your decision criterion at the ... 
      samples.append(x_i)

acceptrate = len(samples)/n
print(samples)
print("accept rate")
print(acceptrate)
#### Plotting tips
# To plot your large collection of samples, use a histogram, via plt.hist()
# It needs the arguments 'density=True', and 'histtype='stepfilled' or it will 
# not visualize correctly!

# If you want to plot a point (x_i, 0), you can use the argument 
# 'clip_on=False'. This way, the point will be plotted on top of the axis 
# boundary, instead of being hidden behind it.